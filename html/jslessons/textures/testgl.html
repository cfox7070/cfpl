<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Textures</title>
    
    <style>
		html, body {
		   margin: 0;
		   height: 100%;
		}
		#c {
		   width: 100%;
		   height: 100%;
		   display: block;
		}
		#loading {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
		}
		#loading .progress {
			margin: 1.5em;
			border: 1px solid white;
			width: 50vw;
		}
		#loading .progressbar {
			margin: 2px;
			background: white;
			height: 1em;
			transform-origin: top left;
			transform: scaleX(0);
		}
	</style>

</head>
<body>
    <canvas id="c" data-engine="three.js r148"></canvas>
    <div id="loading">
		<div class="progress"><div class="progressbar"></div></div>
	</div>
</body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async="" src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
			"three": "./three.r140.module.js"
			
  }
}
</script>

<!--script src="three.js"></script-->

<script type="module" >
import * as THREE from 'three';

/* TODO : Mips*/

function main() {
	const loadingElem = document.querySelector('#loading');
	const progressBarElem = loadingElem.querySelector('.progressbar');
	
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  const fov = 75;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 5;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;

  const scene = new THREE.Scene();

  const boxWidth = 1;
  const boxHeight = 1;
  const boxDepth = 1;
  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
  
  const loadManager = new THREE.LoadingManager();
  const loader = new THREE.TextureLoader(loadManager);
  
 	const materials = [
		  new THREE.MeshBasicMaterial({map: loader.load('flower-1.jpg')}),
		  new THREE.MeshBasicMaterial({map: loader.load('flower-2.jpg')}),
		  new THREE.MeshBasicMaterial({map: loader.load('flower-3.jpg')}),
		  new THREE.MeshBasicMaterial({map: loader.load('flower-4.jpg')}),
		  new THREE.MeshBasicMaterial({map: loader.load('flower-5.jpg')}),
		  new THREE.MeshBasicMaterial({map: loader.load('flower-6.jpg')}),
		];

	const material = new THREE.MeshBasicMaterial({
	  map: loader.load('wall.jpg'),
	});
	
	const cubes = [];
	
	loadManager.onLoad = () => {
	  loadingElem.style.display = 'none';
/*	  const cube = new THREE.Mesh(geometry, materials);
	  scene.add(cube);
	  cubes.push(cube);  // add to our list of cubes to rotate*/
	  cubes.push(makeInstance(geometry, 0x44aa88,  0));
	  cubes.push(makeInstance(geometry, 0x44aa88,  -2));
	  cubes.push(makeInstance(geometry, 0x44aa88,  2));
	};

	loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
	  const progress = itemsLoaded / itemsTotal;
	  progressBarElem.style.transform = `scaleX(${progress})`;
	};

/*	const cubes = [
	  makeInstance(geometry, 0x44aa88,  0),
	  makeInstance(geometry, 0x8844aa, -2),
	  makeInstance(geometry, 0xaa8844,  2),
	];*/
  
  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(-1, 2, 4);
  scene.add(light);
  
	function render(time) {
	  time *= 0.001;  // convert time to seconds
	  
	  if (resizeRendererToDisplaySize(renderer)) {
		  const canvas = renderer.domElement;
		  camera.aspect = canvas.clientWidth / canvas.clientHeight;
		  camera.updateProjectionMatrix();	
	  }
	 cubes.forEach((cube, ndx) => {
		const speed = 1 + ndx * .1;
		const rot = time * speed;
		cube.rotation.x = rot;
		cube.rotation.y = rot;
	  });	
	   
	  renderer.render(scene, camera);
	 
	  requestAnimationFrame(render);
	}
	
	
	function makeInstance(geometry, color, x) {
		
	//  const material = new THREE.MeshPhongMaterial({
	//	  map: loader.load('wall.jpg')});

	  const cube = new THREE.Mesh(geometry, materials);
	  scene.add(cube);
	 
	  cube.position.x = x;
	 
	  return cube;
	}
	
	function resizeRendererToDisplaySize(renderer) {
	  const canvas = renderer.domElement;
	  const pixelRatio = window.devicePixelRatio;
	  const width = canvas.clientWidth / 2  * pixelRatio | 0;
	  const height = canvas.clientHeight / 2  * pixelRatio | 0;
	  const needResize = canvas.width !== width || canvas.height !== height;
	  if (needResize) {
		renderer.setSize(width, height, false);
	  }
	  return needResize;
	}

  requestAnimationFrame(render);
 // renderer.render(scene, camera);
}


main();

</script>

</html>
