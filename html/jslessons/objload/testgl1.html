<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Obj Load</title>
    
    <style>
		html, body {
		   margin: 0;
		   height: 100%;
		}
		#c {
		   width: 100%;
		   height: 100%;
		   display: block;
		}
		#loading {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
		}
		#loading .progress {
			margin: 1.5em;
			border: 1px solid white;
			width: 50vw;
		}
		#loading .progressbar {
			margin: 2px;
			background: white;
			height: 1em;
			transform-origin: top left;
			transform: scaleX(0);
		}
	</style>

</head>
<body>
    <canvas id="c" data-engine="three.js r148"></canvas>
    <div id="loading">
		<div class="progress"><div class="progressbar"></div></div>
	</div>
</body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async="" src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
			"three": "./three.r140.module.js",
			"three/addons/": "./addons/"
  }
}
</script>

<!--script src="three.js"></script-->

<script type="module" >
import * as THREE from 'three';

import {OBJLoader} from 'three/addons/OBJLoader.js';
import {MTLLoader} from 'three/addons/MTLLoader.js';

//TODO: Load small obj

function main() {
	const loadingElem = document.querySelector('#loading');
	const progressBarElem = loadingElem.querySelector('.progressbar');
	loadingElem.style.display = 'none';
	
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});
  renderer.outputEncoding = THREE.sRGBEncoding;
  
  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 100;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(0, 10, 20);

  const scene = new THREE.Scene();
  
{
    const planeSize = 40;

    const loader = new THREE.TextureLoader();
    const texture = loader.load('./checker.png');
    texture.encoding = THREE.sRGBEncoding;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);

    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
 //   scene.add(mesh);
  }

  {
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 0.6;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
  }
  
  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(0, 10, 0);
  light.target.position.set(-5, 0, 0);
  scene.add(light);
  scene.add(light.target);

  const loadManager = new THREE.LoadingManager();
	
	loadManager.onLoad = () => {
	  loadingElem.style.display = 'none';
	};

	loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
	  const progress = itemsLoaded / itemsTotal;
	  progressBarElem.style.transform = `scaleX(${progress})`;
	};

	const objLoader = new OBJLoader();
	  
  /*  const mtlLoader = new MTLLoader();
	  mtlLoader.load('./windmill/windmill.mtl', (mtl) => {
		mtl.preload();
		objLoader.setMaterials(mtl);
		objLoader.load('./windmill/windmill.obj', (root) => {
		  scene.add(root);
		  
		    const box = new THREE.Box3().setFromObject(root);
			  const boxSize = box.getSize(new THREE.Vector3()).length();
			  const boxCenter = box.getCenter(new THREE.Vector3());
			  frameArea(boxSize * 1.2, boxSize, boxCenter, camera);  
		});
	  });*/
	  const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
	  
		objLoader.load('./greencil.obj', (root) => {
			
			   root.traverse(node => {
				 if ('material' in node) {
					 console.log(node.material);
				   node.material = material;
				 }
			   });
		  scene.add(root);
		  
		    const box = new THREE.Box3().setFromObject(root);
			  const boxSize = box.getSize(new THREE.Vector3()).length();
			  const boxCenter = box.getCenter(new THREE.Vector3());
			  console.log(boxSize);
			  frameArea(boxSize * 1.2, boxSize, boxCenter, camera);  
		});
  
	function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
		const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
		const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
		const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
		// compute a unit vector that points in the direction the camera is now
		// from the center of the box
		const direction = (new THREE.Vector3()).subVectors(camera.position, boxCenter).normalize();

		// move the camera to a position distance units way from the center
		// in whatever direction the camera was from the center already
		camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));
		light.position.copy(direction.multiplyScalar(distance).add(boxCenter));
		// pick some near and far values for the frustum that
		// will contain the box.
		camera.near = boxSize / 100;
		camera.far = boxSize * 100;

		camera.updateProjectionMatrix();

		// point the camera to look at the center of the box
		camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
	  }

	function render() {
	  
		if (resizeRendererToDisplaySize(renderer)) {
			  const canvas = renderer.domElement;
			  camera.aspect = canvas.clientWidth / canvas.clientHeight;
			  camera.updateProjectionMatrix();
			}

			renderer.render(scene, camera);

			requestAnimationFrame(render);
   	}
		
	function resizeRendererToDisplaySize(renderer) {
	  const canvas = renderer.domElement;
	  const pixelRatio = window.devicePixelRatio;
	  const width = canvas.clientWidth * pixelRatio | 0;
	  const height = canvas.clientHeight * pixelRatio | 0;
	  const needResize = canvas.width !== width || canvas.height !== height;
	  if (needResize) {
		renderer.setSize(width, height, false);
	  }
	  return needResize;
	}

  requestAnimationFrame(render);
/*	  if (resizeRendererToDisplaySize(renderer)) {
		  const canvas = renderer.domElement;
		  camera.aspect = canvas.clientWidth / canvas.clientHeight;
		  camera.updateProjectionMatrix();	
	  }
  renderer.render(scene, camera);*/
}


main();

</script>

</html>
